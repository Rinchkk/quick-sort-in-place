'''
ID успешной посылки 665552422

--ПРИНЦИП РАБОТЫ--
Я реализовала эффективную быструю сортировку по трем параметрам
right - указатель на конец рассматриваемого участка массива
left - указатель на начало рассматриваемого участка массива
За первый параметр я взяла количество решенных задач;
Второй параметр - штраф за задачи; третий параметр - имя участника олимпиады.
Переменные, включающие в себя название pivot - это опорные элементы.
Алгоритм строится на том, что каждый параметр сортируется либо во возрастанию, либо по убыванию.
Например, первый параметр необходимо отсортировать по убыванию: указатель arr[l] сдвигается слева направо
до тех пор, пока не встречает элемент, который меньше опорного. Тогда начинает двигаться arr[r] справа
налево до тех пор, пока не встретит элемент, который больше опорного. Затем элементы, на которые указывают
указатели меняются местами. Рекурсия заключается в том, что участки массива делятся на все более мелкие
части и сортировка производится в каждом из этих кусков.
Шаг внутри функции partition = 3, поскольку в массиве сортировка проводится по 3м параметрам

--ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ--
Из описания алгоритма следует, что мы сортируем массив для каждого опорного элемента до тех пор, пока
левый указатель <= правого. Затем массив разбивается на 2 части и сортируется уже каждая из этих внутри
аналогичным образом. Таким образом, мы не можем пропустить элемент, который окажется не отсортированным

--ВРЕМЕННАЯ СЛОЖНОСТЬ--
На каждой итерации рекурсии рассматриваемый участок списка делится на 2 части опорным элементом, так же
На каждом шаге рекурсии мы проделываем O(N) операций.
Соответственно, временная сложность алогритма O(NlogN), где N - размер/длина массива

--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--
В условии задачи задано число N - размер/длина списка. Глубина рекурсии оценивается как O(logN).
Так как реализация алгоритма строится на массиве, длина которого не изменяется, а другая память
выделяется на локальные переменные в рекурсии, то пространственная сложность программы составит O(N+logN)
'''

class Participants:
    def __init__(self, login, score, penalty):
        self.login = login
        self.score = int(score)
        self.penalty = int(penalty)

    def __gt__(obj1, obj2):
        return not(obj1.score > obj2.score or obj1.score == obj2.score and (obj1.penalty < obj2.penalty or obj1.penalty == obj2.penalty and obj1.login < obj2.login))

    def __lt__(obj1, obj2):
        return obj1.score > obj2.score or obj1.score == obj2.score and (obj1.penalty < obj2.penalty or obj1.penalty == obj2.penalty and obj1.login < obj2.login)


def quicksort(arr, left, right):
    if right - left > 1:
        elem = partition(arr, left, right)
        quicksort(arr, left, elem)
        quicksort(arr, elem + 1, right)

def partition(arr, left, right):
    pivot = arr[left]
    l = left + 1
    r = right - 1
    while True:
        while l <= r and arr[l] < pivot:
            l += 1
        while l <= r and arr[r] > pivot:
            r -= 1
        if l < r:
            arr[l], arr[r] = arr[r], arr[l]
        elif l > r:
            arr[left], arr[r] = arr[r], arr[left]
            return r

def main():
    n = int(input())
    arr = []
    for i in range(n):
        login, completed_task, penalty = input().split()
        objects = Participants(login, completed_task, penalty)
        arr.append(objects)

    quicksort(arr, 0, n)

    for i in range(n):
        print(arr[i].login)

if __name__ == '__main__':
    main()